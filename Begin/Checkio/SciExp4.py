'''написать функцию для конвертации числа (аргумент number) используя следующие правила. Для начала, необходимо "обрезать" и округлить число до данной базы (аргумент base; по умолчанию 1000). Число должно стать коэффициентом с буквой (или буквами) определяющими степень базы. Коэффициент - это действительное число с определённым числом знаков после точки (аргумент decimals; по умолчанию 0). Вам дан список обозначений степеней (аргумент powers; по умолчанию ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']). Если дан суффикс (аргумент suffix; по умолчанию ‘’) , то необходимо добавить его в конец результата. Коофицент округляется в сторону нуля (5.6⇒5, -5.6⇒-5), если decimal == 0, в остальных случаях используйте стандартное математическое округление. Если данного списка степеней недостаточно, то используйте последний, а дальше, как обычное число. Если необходимое количество знаков после запятой (decimals) больше чем необходимо, то дополняйте нулями. И ноль всегда ноль без всяких степеней.
    n=102
    Результат: "102", база по умолчанию 1000 и 102 меньше данной базы.
    n=10240
    Результат: "10k", база по умолчанию 1000 и округляем вниз.
    n=12341234, decimals=1
    Результат: "12.3M", один знак после точки.
    n=12000000, decimals=3
    Результат: "12.000M", дополняем нулями.
    n=12461, decimals=1
    Результат: "12.5k", стандартное округление.
    n=1024000000, base=1024, suffix='iB'
    Результат: '976MiB', новая база и суффикс.
    n=-150, base=100, powers=['', 'd', 'D']
    Результат: '-1d', Отрицательное число и округление в сторону нуля.
    n=-155, base=100, decimals=1, powers=['', 'd', 'D']
    Результат: '-1.6d', отрицательное число и стандартное округление.
    n=255000000000, powers=['', 'k', 'M']
    Результат: '255000M', недостаточно списка степеней.
Входные данные: Преобразуемое число, как целое число (int). Ключевой аргумент "base", как целое число (int), по умолчанию 1000. Ключевой аргумент "decimals", как целое число (int), по умолчанию 0. Ключевой аргумент "powers", как список (list) строк (str), по умолчанию ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].
Выходные данные: Преобразованое число, как строка (str). 
'''
def friendly_number(num, base=1000, decimals=0, powers=['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'], suffix='' ):
	while len(str(num)-len(str(base))-1 < len(str(base))-1:
		
	return  + suffix






if __name__ == '__main__':
    assert friendly_number(102) == '102', '102'
    assert friendly_number(10240) == '10k', '10k'
    assert friendly_number(12341234, decimals=1) == '12.3M', '12.3M'
    assert friendly_number(12461, decimals=1) == '12.5k', '12.5k'
    assert friendly_number(1024000000, base=1024, suffix='iB') == '976MiB', '976MiB'